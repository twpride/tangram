<h1 align="center">179 Tangrams</h1>
<div align="center" >
 <a href="https://twpride.github.io/tangram/">
 Live Site
 </a>
</div>
<p align="center">
 <img width="360" height="auto" src="https://raw.githubusercontent.com/twpride/tangram/master/demo/gamefull_opt.gif">
</p>


179 Tangrams is a browser implementation of a classic Chinese puzzle using plain JavaScript(no packages) and the [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API). The puzzle consists of seven polygons tiles, which are put together to form shapes. The objective is to replicate a pattern (generally found in a puzzle book) using all seven tiles without overlap.


# Challenges
 
## Solve state detection

A dimension that is unique to this implementation Tangram is that the player is scored by how quickly he/she can solve a puzzle. A timer automatically starts when the player enters a level and is only stopped whenever the user exits (by hitting pause, or switching tabs) or when the puzzle is solved. 

This added timing component meant that the program would constantly need to check whether the puzzle had been solved. For this task, a raster based overlap detection algorithm was developed. 

The approach starts out with painting the silhouette then the tangram tiles on a secondary canvas that is off-screen. By ensuring that the geometric centers of the silhouette and the tangram tiles align, it follows that there is maximum overlap between the tangram tiles and the silhouette when the puzzle is solved. Conversely, this means that the non-overlapping areas of the silhouette is at a minimum.
 
To detect this solved state where the non-overlapping silhouette area is at a minimum, we set both the canvas background and the tangram shapes to black (rgb(0,0,0)) while the silhouette set to any non-black color which in our case was cyan, most importantly with a red color value of 1, rgb(1,255,255). Since the tangrams shapes are painted after the silhouette, any overlapping areas will be set to black, whereas the non-overlapping areas of the silhouette remain cyan.
 
After every tile move, the program sums the red pixel values of all the pixels on the secondary canvas. Since we had set the silhouette to have a red color value of 1, the sum is also the number of pixels of silhouette that is non-overlapping. If the non-overlap pixel count is below a certain threshold (empirically determined), we can conclude that the player has solved the puzzle. 

The screenshot below shows live game play with the secondary canvas overlayed on top. As the tiles on the main canvas moves, the secondary canvas is also updated. The green counter is a live reading of sum of cyan pixels currently displayed. Notice that when the when the probem solved, the green coutner drops to below 5000 and the timer stops. 
 
<p align="center">
 <img width="360" height="auto" src="https://raw.githubusercontent.com/twpride/tangram/master/demo/sil_opt.gif">
</p>

<br/>

## A custom carousel for the puzzle selector

<p align="center">
 <img width="480" height="auto" src="https://raw.githubusercontent.com/twpride/tangram/master/demo/slider_opt.gif">
</p>

### Hover preview
As the use hover the mouse over each problem icon in the carousel, the game canvas updates with a preview of the problem and the current state of the tiles in that level. The silhouette for unsolved problems are blurred in the preview to prevent the player from getting a head start before starting the timer.

### Integrated heatmap
The carousel also functions as a heat map that tracks the player's progress. The heat maps colors each level icon depending on elapsed time and solve state of each level. The heatmap was generated by formatting an [HSL](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl_colors) color string which becomes an attributes of a SVG [&lt;rect&gt;](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect) element.

The heat map adds a badge-like reward mechanism to the gameplay experience. The user may be motivated to fill up the entire carousel with green boxes :)
 
### Page snap easing animation
To allow for smooth transition between pages, the carousel utilizes a [Bezier easing function](https://github.com/gre/bezier-easing) to generate the animation of snapping to a page.

 
## Collision detection
Adding realism to the game play, the program checks for collision between the puzzle tiles. After every tile move, if there was a collision, the penetration amount between the penetrating vertex and the penetrated edge is calculated.
 
The moving tile is then shifted back by the calculated intersection amount ensuring that the tiles are no longer colliding
 
<p align="center">
 <img width="480" height="auto" src="https://raw.githubusercontent.com/twpride/tangram/master/demo/collision_opt.gif">
</p>


## Puzzle generation
Instead of generating the problem manually, examples of tangram problems found online were leveraged. The 179 puzzles in this game was taken from a [puzzle booklet](https://web.archive.org/web/20200203050759/https://www.cs.brandeis.edu/~storer/JimPuzzles/ZPAGES/zzzRichter08-AnchorPuzzle.html) first published in 1890 by the Richter Company of Germany in 1890. The problems were extracted from scanned images of the puzzle booklet with a python script using OpenCv's `findContours()`.
 
## Game Controls
- tile translation
  - Mouse: Left click and drag
  - Touch: Tap and drag
- tile rotation
  - Mouse: Right click and drag
  - Two-finger touch: With 1 finger touching the tile, drag with second finger
  - One-finger touch: Double tap tile. Drag on second tap
- Lifting a tile up (so it can move through other tiles)
  - Mouse: double click
  - With touch: long press
- Flipping the parallelogram
  - Click on the button below the play/pause button.
- Exiting or pausing the puzzle
  - Click the pause button, or press &lt;Escape&gt;
 
 
 
 







